{"version":3,"file":"author-base.es5.min.js","sources":["../src/element.js"],"sourcesContent":["const AuthorBaseElement = superClass => class extends superClass {\n  constructor (templateString) {\n    super()\n\n    Object.defineProperties(this, {\n      /**\n       * @property PRIVATE\n       * Storage Object for private methods and properties. Used internally.\n       * @type {object}\n       */\n      PRIVATE: {\n        value: {}\n      },\n\n      /**\n       * @property UTIL\n       * Storage Object for utility methods and properties.\n       * @type {object}\n       */\n      UTIL: {\n        value: {}\n      }\n    })\n\n    Object.defineProperties(this.PRIVATE, {\n      /**\n       * @property attributes\n       * Used internally to manage registered attributes.\n       * @private\n       */\n      attributes: {\n        value: {}\n      },\n\n      /**\n       * @property booleanAttributes\n       * Used internally to manage registered boolean attributes.\n       * @private\n       */\n      booleanAttributes: {\n        value: {}\n      },\n\n      /**\n       * @property properties\n       * Used internally to manage registered properties.\n       * @private\n       */\n      properties: {\n        value: {}\n      },\n\n      /**\n       * @property privateProperties\n       * Used internally to manage registered private properties.\n       * @private\n       */\n      privateProperties: {\n        value: []\n      },\n\n      /**\n       * @property listeners\n       * Used internally to manage registered event listeners.\n       * @private\n       */\n      listeners: {\n        value: []\n      },\n\n      /**\n       * @property styleRules\n       * Used internally to manage styling added to the component's internal stylesheet.\n       * @private\n       */\n      styleRules: {\n        value: {}\n      },\n\n      /**\n       * @property initialize\n       * Used internally to set up the element's Shadow Root and inject its template.\n       * @private\n       */\n      initialize: {\n        value: templateString => {\n          this.keySource = 'key' in KeyboardEvent.prototype ? 'key' : ('keyIdentifier' in KeyboardEvent.prototype ? 'keyIdentifier' : 'keyCode')\n\n          this.attachShadow({ mode: 'open' })\n\n          let container = document.createElement('div')\n          container.insertAdjacentHTML('afterbegin', templateString)\n\n          let template = container.querySelector('template')\n\n          if ('content' in template) {\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n          } else {\n            template.childNodes.forEach((child) => {\n              this.shadowRoot.appendChild(child.cloneNode(true))\n            })\n          }\n\n          template = null\n          this.crypto = null\n\n          try {\n            this.crypto = crypto\n          } catch (e) {\n            this.crypto = msCrypto\n          }\n        }\n      },\n\n      /**\n       * @method definePrivateProperty\n       * Used internally to register new private properties on the element\n       * @param  {string} name\n       * @param  {CustomPropertyObject} data\n       * @private\n       */\n      definePrivateProperty: {\n        value: (name, data) => {\n          this.PRIVATE.privateProperties[name] = null\n\n          Object.defineProperty(this.PRIVATE, name, {\n            get: () => {\n              if (data.hasOwnProperty('get')) {\n                if (typeof data.get !== 'function') {\n                  return this.UTIL.throwError({\n                    type: 'type',\n                    message: 'Property getter must be a function'\n                  })\n                }\n\n                return data.get()\n              }\n\n              return this.PRIVATE.privateProperties[name] === null ? data.default : this.PRIVATE.privateProperties[name]\n            },\n\n            set: value => {\n              if (data.readonly) {\n                return this.UTIL.throwError({\n                  type: 'readonly',\n                  vars: { prop: name }\n                })\n              }\n\n              this.PRIVATE.privateProperties[name] = value\n            }\n          })\n        }\n      },\n\n      /**\n       * @method defineReadOnlyProperty\n       * Used internally to register new readonly properties on the element.\n       * @param  {string} name\n       * @param  {CustomPropertyObject} data\n       * @private\n       */\n      defineReadOnlyProperty: {\n        value: (name, data) => {\n          let cfg = {\n            set: value => {\n              this.UTIL.throwError({\n                type: 'readonly',\n                vars: { prop: name }\n              })\n            },\n\n            get: () => {\n              if (data.hasOwnProperty('get')) {\n                if (typeof data.get !== 'function') {\n                  return this.UTIL.throwError({\n                    type: 'type',\n                    message: 'Property getter must be a function'\n                  })\n                }\n\n                return data.get()\n              }\n\n              return data.hasOwnProperty('default') ? data.default : null\n            }\n          }\n\n          Object.defineProperty(this, name, cfg)\n        }\n      },\n\n      /**\n       * @method generateAuthorHTMLCollectionConstructor\n       * Generates a class constructor for an AuthorHTMLCollection\n       * @returns {AuthorHTMLCollection}\n       * @private\n       */\n      generateAuthorHTMLCollectionConstructor: {\n        value: function () {\n          let _p = new WeakMap()\n\n          let AuthorHTMLCollection = class AuthorHTMLCollection {\n            constructor (arr) {\n              _p.set(this, { arr })\n              arr.forEach((node, index) => {\n                this[index] = node\n\n                if (node.id) {\n                  this[node.id] = node\n                }\n              })\n            }\n\n            get length () {\n              return _p.get(this).arr.length\n            }\n\n            item (index) {\n              return _p.get(this).arr[index]\n            }\n\n            namedItem (name) {\n              let matches = _p.get(this).arr.filter(item => item.id === name || item.name === name)\n              return matches.length > 0 ? matches[0] : null\n            }\n\n            [Symbol.iterator] () {\n              let index = 0\n\n              return {\n                next: () => {\n                  let result = {\n                    value: _p.get(this).arr[index],\n                    done: !(index in _p.get(this).arr)\n                  }\n\n                  index++\n\n                  return result\n                }\n              }\n            }\n\n            [Symbol.toStringTag] () {\n              return 'AuthorHTMLCollection'\n            }\n          }\n\n          return AuthorHTMLCollection\n        }\n      },\n\n      getStyleRule: {\n        value: name => {\n          let rule = this.PRIVATE.styleRules[name]\n\n          if (!rule) {\n            return this.UTIL.throwError({\n              message: `Style Rule \"${name}\" not found`\n            })\n          }\n\n          return rule\n        }\n      },\n\n      /**\n       * @method getBooleanAttributeValue\n       * Used internally. Returns a validated boolean attribute value.\n       * @param  {string} name\n       * @return {boolean}\n       * @private\n       */\n      getBooleanAttributeValue: {\n        value: name => this.hasAttribute(name) && this.getAttribute(name) !== 'false'\n      },\n\n      /**\n       * @method setBooleanAttributeValue\n       * Used internally. Ensures that a boolean attribute recieves a valid\n       * boolean as a value.\n       * @param  {string} name\n       * @param  {any} value\n       * @private\n       */\n      setBooleanAttributeValue: {\n        value: (name, value) => {\n          if (typeof value === 'boolean') {\n            value = value.toString()\n          }\n\n          let acceptableValues = ['true', 'false', '', null]\n\n          if (!acceptableValues.includes(value)) {\n            this.UTIL.printToConsole(`\"${name}\" attribute expected boolean but received \"${value}\"`, 'error')\n            return this.removeAttribute(name)\n          }\n\n          switch (value) {\n            case 'false':\n            case null:\n              return this.removeAttribute(name)\n\n            case 'true':\n            case '':\n              return this.setAttribute(name, '')\n          }\n        }\n      },\n    })\n\n    Object.defineProperties(this.UTIL, {\n      /**\n       * @property childMonitor\n       * The MutationObserver instance created upon calling this.UTIL.monitorChildren.\n       * @type {MutationObserver}\n       */\n      childMonitor: {\n        value: null\n      },\n\n      /**\n       * @typedef {object} CustomAttributeObject shape: {\n       *   get: {function} Custom getter\n       *   set: {function} Custom setter\n       *   default: {any} Default value\n       * }\n       */\n\n      /**\n       * @method defineAttribute\n       * Registers a new attribute on the element and connects it to a new\n       * property of the same name.\n       * @param  {string} name\n       * @param  {string|number|boolean|CustomAttributeObject} defaultValue\n       * If a default value is passed, or if a CustomAttributeObject is passed\n       * which includes a \"default\" property, getters will be applied that\n       * return the default value if the actual value is null or undefined.\n       */\n      defineAttribute: {\n        value: (name, defaultValue) => {\n          let customGetter = null\n          let customSetter = null\n\n          if (typeof defaultValue === 'object') {\n            let cfg = defaultValue\n\n            if (cfg.hasOwnProperty('get')) {\n              customGetter = cfg.get\n            }\n\n            if (cfg.hasOwnProperty('set')) {\n              customSetter = cfg.set\n            }\n\n            defaultValue = cfg.hasOwnProperty('default') ? cfg.default : null\n          }\n\n          let isBool = typeof defaultValue === 'boolean'\n          let privateKey = isBool ? 'booleanAttributes' : 'attributes'\n\n          Object.defineProperty(this.PRIVATE[privateKey], name, {\n            get: () => {\n              if (customGetter) {\n                let result = customGetter()\n                return result === null ? defaultValue : result\n              }\n\n              return defaultValue\n            },\n\n            set: value => customSetter && customSetter(value)\n          })\n\n          Object.defineProperty(this, name, {\n            get: () => {\n              if (customGetter) {\n                let result = customGetter()\n                return result === null ? defaultValue : result\n              }\n\n              if (isBool) {\n                return this.PRIVATE.getBooleanAttributeValue(name)\n              }\n\n              return this.hasAttribute(name) ? this.getAttribute(name) : defaultValue\n            },\n\n            set: value => {\n              customSetter && customSetter(value)\n\n              if (customGetter) {\n                value = this.PRIVATE[privateKey][name]\n              }\n\n              if (isBool) {\n                return this.PRIVATE.setBooleanAttributeValue(name, value)\n              }\n\n              this.setAttribute(name, value)\n            }\n          })\n        }\n      },\n\n      /**\n       * @method defineAttributes\n       * Define multiple attributes at once.\n       * @param  {object} attrs\n       * Example:\n       * {\n       *   booleanAttr: false,\n       *   stringAttr: 'string',\n       *   customAttr: {\n       *     get: () => this.customAttribute,\n       *     default: 'defaultValue'\n       *   }\n       * }\n       *\n       * Custom attributes are configured as CustomAttributeObject\n       */\n      defineAttributes: {\n        value: attrs => {\n          for (let attr in attrs) {\n            this.UTIL.defineAttribute(attr, attrs[attr])\n          }\n        }\n      },\n\n      /**\n       * @typedef {object} CustomPropertyObject shape: {\n       *   readonly: {boolean} optional\n       *   private: {boolean} optional,\n       *   default: {any} Default property value,\n       *   get: {function} Custom Getter,\n       *   set: {function} Custom setter\n       * }\n       */\n\n      /**\n       * @method defineProperty\n       * Registers a custom property on the element. If an attribute of the same\n       * name already exists, its paired property will be overwritten.\n       * @param  {string} name\n       * @param  {string|boolean|number|CustomPropertyObject} value\n       */\n      defineProperty: {\n        value: (name, value) => {\n          if (typeof value !== 'object' || value === null) {\n            this.PRIVATE.properties[name] = value\n            this[name] = value\n            return\n          }\n\n          let data = {\n            readonly: value.hasOwnProperty('readonly') && value.readonly === true,\n            private: value.hasOwnProperty('private') && value.private === true,\n            default: value.hasOwnProperty('default') ? value.default : null\n          }\n\n          if (value.hasOwnProperty('get')) {\n            if (typeof value.get !== 'function') {\n              return this.UTIL.throwError({\n                type: 'type',\n                message: 'Property getter must be a function'\n              })\n            }\n\n            data.get = value.get\n          }\n\n          if (value.hasOwnProperty('set')) {\n            if (typeof value.set !== 'function') {\n              return this.UTIL.throwError({\n                type: 'type',\n                message: 'Property setter must be a function'\n              })\n            }\n\n            data.set = value.set\n          }\n\n          if (value.private) {\n            return this.PRIVATE.definePrivateProperty(name, data)\n          }\n\n          if (value.readonly) {\n            return this.PRIVATE.defineReadOnlyProperty(name, data)\n          }\n\n          this.PRIVATE.properties[name] = data.default\n\n          Object.defineProperty(this, name, {\n            get: () => {\n              if (data.hasOwnProperty('get')) {\n                return data.get()\n              }\n\n              return this.PRIVATE.properties[name] === null ? data.default : this.PRIVATE.properties[name]\n            },\n\n            set: value => {\n              if (data.hasOwnProperty('set')) {\n                return data.set(value)\n              }\n\n              this.PRIVATE.properties[name] = value\n            }\n          })\n        }\n      },\n\n      /**\n       * @method defineProperties\n       * Register multiple properties at once on the element.\n       * @param  {object} properties\n       * Example: {\n       *   booleanProperty: false,\n       *   stringProperty: 'string',\n       *   customProperty: {\n       *     readonly: true,\n       *     private: true,\n       *     get: () => {\n       *       doSomething()\n       *       return this.customProperty\n       *     },\n       *     default: 'default value'\n       *   }\n       * }\n       */\n      defineProperties: {\n        value: properties => {\n          for (let property in properties) {\n            this.UTIL.defineProperty(property, properties[property])\n          }\n        }\n      },\n\n      /**\n       * @method definePrivateMethods\n       * Register multiple private methods on the element. These will be added\n       * tp the element's \"PRIVATE\" object and can be accessed via this.PRIVATE.*\n       * @param  {object} methods\n       * Example {\n       *   myPrivateMethod: () => doSomething()\n       * }\n       */\n      definePrivateMethods: {\n        value: methods => {\n          for (let method in methods) {\n            if (this.PRIVATE.hasOwnProperty(method)) {\n              return this.UTIL.throwError({\n                message: `Cannot create private method. Property name \"${method}\" is already in use.`\n              })\n            }\n\n            this.PRIVATE[method] = methods[method]\n          }\n        }\n      },\n\n      /**\n       * @method createEvent\n       * Returns a new CustomEvent object.\n       * @param  {[type]} name\n       * Name of the event\n       * @param  {object} detail\n       * Properties to add to event.detail\n       * @return {CustomEvent}\n       */\n      createEvent: {\n        value: (name, detail) => {\n          return new CustomEvent(name, { detail })\n        }\n      },\n\n      /**\n       * @method generateGuid\n       * @param  {string} [prefix=null]\n       * String to prepend to the beginning of the id.\n       * @param  {string} [postfix=null]\n       * String to append to the end of the id.\n       * @return {string}\n       * New RFC-compliant GUID\n       */\n      generateGuid: {\n        value: (prefix = null, postfix = null) => {\n          let id = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => { // eslint-disable-line space-infix-ops\n            return (c ^ this.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n          })\n\n          if (prefix) {\n            id = `${prefix}${id}`\n          }\n\n          if (postfix) {\n            id = `${id}${postfix}`\n          }\n\n          return id\n        }\n      },\n\n      /**\n       * @method insertStyleRule\n       * Inserts a new CSS rule-set into the component's shadow root style sheet.\n       * @param {string} name\n       * Unique identifier to be used as an accessor for this rule-set\n       * @param {string} selector\n       * CSS selector string\n       * @param {number} index [optional]\n       * Index at which to add the new style rule\n       */\n      insertStyleRule: {\n        value: (name, selector, index = this.PRIVATE.styleSheet.cssRules.length) => {\n          this.PRIVATE.styleSheet.insertRule(selector, index)\n          this.PRIVATE.styleRules[name] = {\n            default: this.PRIVATE.styleSheet.cssRules[index],\n          }\n\n          if (selector.includes(':host(')) {\n            selector = `${this.localName}${/\\(([^)]+)\\)/.exec(selector)[1]} {}`\n            index += 1\n\n            if (selector) {\n              this.PRIVATE.styleSheet.insertRule(selector, index)\n              this.PRIVATE.styleRules[name].legacy = this.PRIVATE.styleSheet.cssRules[index]\n            }\n          }\n        }\n      },\n\n      /**\n       * @method insertStyleRules\n       * Inserts one or more new CSS rule-sets into the component's shadow root style sheet.\n       * @param {object} rules\n       * CSS selector string or definition object. If using a definition object, the key name\n       * will be used as an accessor for this rule.\n       * @param {string} rules.selector\n       * CSS selector string\n       * @param {string} rules.index [optional]\n       * Index at which to insert the new rule into the style sheet.\n       */\n      insertStyleRules: {\n        value: rules => {\n          for (let rule in rules) {\n            let input = rules[rule]\n\n            if (typeof input === 'string') {\n              this.UTIL.insertStyleRule(rule, input)\n              continue\n            }\n\n            if (Array.isArray(input) || typeof input !== 'object') {\n              return this.UTIL.throwError({\n                type: 'type',\n                message: `Invalid Style Rule definition \"${JSON.stringify(input)}\". Definitions must either be a valid CSS selector string or an object`\n              })\n            }\n\n            if (!input.hasOwnProperty('selector')) {\n              return this.UTIL.throwError({\n                message: 'Style Rule Definition must include a \"selector\" property'\n              })\n            }\n\n            this.insertStyleRule(rule, input.selector, input.hasOwnProperty('index') ? input.index : null)\n          }\n        }\n      },\n\n      /**\n       * @method removeStyleProperty\n       * Removes a style property declaration from the specified rule in the component's shadow root style sheet.\n       * @param {string} ruleName\n       * Name of the rule\n       * @param {string} propertyName\n       * CSS property name\n       */\n      removeStyleProperty: {\n        value: (ruleName, propertyName) => {\n          let rule = this.PRIVATE.getStyleRule(ruleName)\n\n          rule.default.style.removeProperty(propertyName)\n\n          if (rule.hasOwnProperty('legacy')) {\n            rule.legacy.style.removeProperty(propertyName)\n          }\n        }\n      },\n\n      /**\n       * @method removeStyleProperties\n       * Removes a set of style property declarations from the specified rule in the component's shadow root style sheet.\n       * @param {string} ruleName\n       * Name of the rule\n       * @param {array} propertyNames\n       * Names of the CSS properties to remove\n       */\n      removeStyleProperties: {\n        value: (ruleName, propertyNames) => {\n          if (!Array.isArray(propertyNames)) {\n            return this.UTIL.throwError({\n              type: 'type',\n              message: `Style property names must be an array of strings`\n            })\n          }\n\n          propertyNames.forEach(propertyName => this.UTIL.removeStyleProperty(ruleName, propertyName))\n        }\n      },\n\n      /**\n       * @method setStyleProperty\n       * Adds a new style declaration to the component's shadow root style sheet, or updates an existing one.\n       * @param {string} ruleName\n       * String identifier for the style rule to add the declaration to.\n       * @param {string} propertyName\n       * CSS property\n       * @param {string} propertyValue\n       * CSS property value\n       * @param {boolean} important [optional]\n       * true sets the important flag on this property declaration.\n       */\n      setStyleProperty: {\n        value: (ruleName, propertyName, propertyValue, important = false) => {\n          let rule = this.PRIVATE.getStyleRule(ruleName)\n\n          rule.default.style.setProperty(propertyName, propertyValue, important ? 'important' : undefined)\n\n          if (rule.hasOwnProperty('legacy')) {\n            rule.legacy.style.setProperty(propertyName, propertyValue, important ? 'important' : undefined)\n          }\n        }\n      },\n\n      /**\n       * @method setStyleProperties\n       * Adds a set of new style declarations to the component's shadow root style sheet, or updates existing ones.\n       * @param {string} ruleName\n       * String identifier for the style rule to add the declaration to.\n       * @param {array} properties\n       * Array of objects of shape: {\n       *   name: {string} CSS property name,\n       *   value: {string} CSS property value,\n       *   important: {boolean} Determines whether or not to set the !important flag [optional]\n       * }\n       */\n      setStyleProperties: {\n        value: (ruleName, properties) => {\n          if (!Array.isArray(properties)) {\n            return this.UTIL.throwError({\n              type: 'type',\n              message: `Style properties must be an array of objects`\n            })\n          }\n\n          properties.forEach(property => {\n            let important = property.hasOwnProperty('important') && property.important === true\n            this.UTIL.setStyleProperty(ruleName, property.name, property.value, important)\n          })\n        }\n      },\n\n      /**\n       * @typedef {string} ErrorType (custom, dependency, readonly, reference, type)\n       * Indentifier for JavaScript built-in Error types including:\n       * Error, TypeError, ReferenceError, or custom Error\n       */\n\n      /**\n       * @method throwError\n       * Throws a customizable new Error.\n       * @param {object} properties\n       * @property {ErrorType} type\n       * Type of error to throw. For example, 'reference' will throw a\n       * new ReferenceError() instance, while 'type' will throw a new TypeError()\n       * instance. Other values will throw customizable new Error() instances.\n       * @property {object} vars\n       * Some error types have default messages which accept interpolated variables.\n       * For example, 'dependency' errors accept an options 'name' variable, the\n       * value of which should be the name of the missing dependency. They also\n       * accept a 'url' variable, the value of which should be a url where the\n       * dependency can be acquired.\n       * @property {string} message\n       * A custom message to append to the default error message.\n       *\n       * Example usage:\n       * ```js\n       * this.UTIL.throwError({\n       *   type: 'dependency',\n       *   vars: {\n       *     name: 'NGN',\n       *     url: 'https://github.com/ngnjs/NGN'\n       *   },\n       *   message: 'NGN makes development a breeze!'\n       * })\n       * ```\n       */\n      throwError: {\n        value: properties => {\n          let finalMessage = `<${this.localName}> `\n\n          let type = properties.hasOwnProperty('type') ? properties.type : 'custom'\n          let error = new Error()\n          let { vars } = properties\n\n          if (type === 'dependency') {\n            finalMessage += 'Missing dependency'\n\n            if (vars) {\n              if (vars.hasOwnProperty('name')) {\n                finalMessage += `: ${vars.name}`\n              }\n\n              if (vars.hasOwnProperty('url')) {\n                finalMessage += ` ${vars.url}`\n              }\n            }\n\n          } else if (type === 'readonly') {\n            finalMessage += `Cannot set read-only property`\n\n            if (vars && vars.hasOwnProperty('prop')) {\n              finalMessage += ` \"${vars.prop}\"`\n            }\n\n          } else if (type === 'reference') {\n            error = new ReferenceError()\n\n          } else if (type === 'type') {\n            error = new TypeError()\n\n          } else {\n            return this.UTIL.throwError({\n              message: `Unrecognized error type \"${type}\". Accepted types: \"custom\", \"dependency\", \"readonly\", \"reference\", \"type\"`\n            })\n          }\n\n          if (properties.hasOwnProperty('message')) {\n            finalMessage += ` ${properties.message}`\n          }\n\n          error.message = finalMessage.trim()\n          throw error\n        }\n      },\n\n      /**\n        * @typedef {string} ConsoleLogType (warning, error, info, log)\n        * Indentifier for window.console built-in methods including:\n        * warn(), error(), info(), log()\n        */\n\n      /**\n       * @method printToConsole\n       * Prints a message to the console, along with the tag-name of the element.\n       * Can print customizable warnings, errors, info, or default logs.\n       * @param {string} message\n       * Message to print.\n       * @param {ConsoleLogType} [type = 'log']\n       * Type of message to print to the console. This will determine which\n       * method of the window.console object is used to print the message.\n       */\n      printToConsole: {\n        value: (message, type = 'log') => {\n          let finalMessage = `<${this.localName}> ${message}`\n\n          switch (type) {\n            case 'warning': return console.warn(`[WARNING] ${finalMessage}`)\n            case 'error': return console.error(`[ERROR] ${finalMessage}`)\n            case 'info': return console.info(finalMessage)\n            default: return console.log(finalMessage)\n          }\n        }\n      },\n\n      /**\n       * @method monitorChildren\n       * Applies a MutationObserver to the element.\n       * @param {function} callback\n       * Runs when a mutation occurs\n       * @param {Boolean} [subtree = false]\n       * Determines whether or not to observe changes to the descendants of the target node\n       */\n      monitorChildren: {\n        value: (callback, cfg = null) => {\n          this.childMonitor = new MutationObserver(callback)\n\n          cfg = cfg || {\n            childList: true,\n            attributes: false,\n            characterData: false,\n            subtree: false\n          }\n\n          this.childMonitor.observe(this, cfg)\n        }\n      },\n\n      /**\n       * @method registerListener\n       * Applies an event listener. This listener will be automatically cleaned up\n       * upon element disconnect.\n       * @param {DOMNode} element\n       * Element to which to apply the event listener.\n       * @param {string} evtName\n       * Name of the event to listen to.\n       * @param {function} callback\n       * Function to call upon firing of the event.\n       */\n      registerListener: {\n        value: (element, evtName, callback) => {\n          let listener = {\n            id: `listener_${this.UTIL.generateGuid()}`,\n            apply: () => element.addEventListener(evtName, callback),\n            remove: () => element.removeEventListener(evtName, callback)\n          }\n\n          this.PRIVATE.listeners.push(listener)\n          listener.apply()\n        }\n      },\n\n      /**\n       * @method registerListeners\n       * Applies multiple event listeners at once. Each listener will be automatically cleaned up\n       * upon element disconnect.\n       * @param {DOMNode} element\n       * Element to which to apply all the event listeners.\n       * @param {{name: String, callback: Function}[]} listeners\n       * Event Listeners to apply.\n       */\n      registerListeners: {\n        value: (element, listeners) => {\n          for (let listener in listeners) {\n            this.UTIL.registerListener(element, listener, listeners[listener])\n          }\n        }\n      }\n    })\n\n    this.PRIVATE.initialize(templateString)\n  }\n\n  /**\n   * @override\n   * @method attributeChangedCallback\n   * Synchronizes attribute/property updates.\n   * @param  {string} attribute\n   * @param  {string} oldValue\n   * @param  {string} newValue\n   * @fires attribute.change\n   * Fires before change is applied to matching properties.\n   * @fires attribute.changed\n   * Fires after change has been applied to matching properties.\n   */\n  attributeChangedCallback (attribute, oldValue, newValue) {\n    this.emit('attribute.change', {\n      attribute,\n      oldValue,\n      newValue\n    })\n\n    let { attributes, booleanAttributes } = this.PRIVATE\n\n    if (attributes.hasOwnProperty(attribute) && attributes[attribute] !== newValue) {\n      this.PRIVATE.attributes[attribute] = newValue\n    } else if (booleanAttributes.hasOwnProperty(attribute) && newValue !== 'true' && newValue !== '') {\n      this.PRIVATE.booleanAttributes[attribute] = newValue\n    }\n\n    this.emit('attribute.changed', {\n      attribute,\n      oldValue,\n      newValue\n    })\n  }\n\n  /**\n   * @override\n   * @method connectedCallback\n   * Fires events upon element connection.\n   * @fires 'connected'\n   * @fires 'rendered'\n   * Fires once the element's children have been rendered to the DOM.\n   */\n  connectedCallback () {\n    Object.defineProperty(this.PRIVATE, 'styleSheet', {\n      value: this.shadowRoot.querySelector('style').sheet\n    })\n\n    this.emit('connected')\n    setTimeout(() => this.emit('rendered'), 0)\n  }\n\n  /**\n   * @override\n   * @method disconnectedCallback\n   * Removes all registered event listeners upon element disconnect.\n   * @fires 'disconnected'\n   */\n  disconnectedCallback () {\n    this.PRIVATE.listeners.forEach(listener => listener.remove())\n    this.emit('disconnected')\n  }\n\n  /**\n   * @method emit\n   * Dispatches a new CustomEvent()\n   * @param  {string} name\n   * Name of event to dispatch\n   * @param  {object} detail\n   * Data object to include in the event's payload\n   * @param  {HTMLElement} [target=null]\n   * DOM node to fire the event at.\n   */\n  emit (name, detail, target = null) {\n    let event = this.UTIL.createEvent(name, detail)\n\n    if (target) {\n      return target.dispatchEvent(event)\n    }\n\n    this.dispatchEvent(event)\n  }\n\n  /**\n   * @method off\n   * Convenience method. Removes an event listener from the element.\n   * @param  {string}   evtName\n   * @param  {function} handler\n   */\n  off (evtName, handler) {\n    this.removeEventListener(evtName, handler)\n  }\n\n  /**\n   * @method on\n   * Convenience method. Attaches an event listener to the element.\n   * @param  {string}   evtName\n   * @param  {function} handler\n   * Called when the event is fired.\n   */\n  on (evtName, handler) {\n    this.addEventListener(evtName, handler)\n  }\n}\n\nexport default AuthorBaseElement\n"],"names":["superClass","templateString","Object","defineProperties","PRIVATE","value","UTIL","_this","attributes","booleanAttributes","properties","privateProperties","listeners","styleRules","initialize","keySource","KeyboardEvent","prototype","attachShadow","mode","container","document","createElement","insertAdjacentHTML","template","querySelector","shadowRoot","appendChild","content","cloneNode","childNodes","forEach","child","crypto","e","msCrypto","definePrivateProperty","name","data","defineProperty","get","hasOwnProperty","throwError","type","message","default","set","readonly","vars","prop","defineReadOnlyProperty","cfg","generateAuthorHTMLCollectionConstructor","_p","WeakMap","arr","this","node","index","_this2","id","matches","filter","item","length","Symbol","iterator","next","result","_this3","done","toStringTag","getStyleRule","rule","getBooleanAttributeValue","hasAttribute","getAttribute","setBooleanAttributeValue","toString","includes","printToConsole","removeAttribute","setAttribute","childMonitor","defineAttribute","defaultValue","customGetter","customSetter","_typeof","isBool","privateKey","defineAttributes","attrs","attr","private","property","definePrivateMethods","methods","method","createEvent","detail","CustomEvent","generateGuid","prefix","postfix","replace","c","getRandomValues","Uint8Array","insertStyleRule","selector","styleSheet","cssRules","insertRule","localName","exec","legacy","insertStyleRules","rules","input","Array","isArray","JSON","stringify","removeStyleProperty","ruleName","propertyName","style","removeProperty","removeStyleProperties","propertyNames","setStyleProperty","propertyValue","important","setProperty","undefined","setStyleProperties","finalMessage","error","Error","url","ReferenceError","TypeError","trim","console","warn","info","log","monitorChildren","callback","MutationObserver","childList","characterData","subtree","observe","registerListener","element","evtName","listener","apply","addEventListener","remove","removeEventListener","push","registerListeners","attribute","oldValue","newValue","emit","sheet","setTimeout","_this4","target","event","dispatchEvent","handler"],"mappings":"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"}