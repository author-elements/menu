{"version":3,"file":"author-base.min.js","sources":["../src/element.js"],"sourcesContent":["const AuthorBaseElement = superClass => class extends superClass {\n  constructor (templateString) {\n    super()\n\n    Object.defineProperties(this, {\n      /**\n       * @property PRIVATE\n       * Storage Object for private methods and properties. Used internally.\n       * @type {object}\n       */\n      PRIVATE: {\n        value: {}\n      },\n\n      /**\n       * @property UTIL\n       * Storage Object for utility methods and properties.\n       * @type {object}\n       */\n      UTIL: {\n        value: {}\n      }\n    })\n\n    Object.defineProperties(this.PRIVATE, {\n      /**\n       * @property attributes\n       * Used internally to manage registered attributes.\n       * @private\n       */\n      attributes: {\n        value: {}\n      },\n\n      /**\n       * @property booleanAttributes\n       * Used internally to manage registered boolean attributes.\n       * @private\n       */\n      booleanAttributes: {\n        value: {}\n      },\n\n      /**\n       * @property properties\n       * Used internally to manage registered properties.\n       * @private\n       */\n      properties: {\n        value: {}\n      },\n\n      /**\n       * @property privateProperties\n       * Used internally to manage registered private properties.\n       * @private\n       */\n      privateProperties: {\n        value: []\n      },\n\n      /**\n       * @property listeners\n       * Used internally to manage registered event listeners.\n       * @private\n       */\n      listeners: {\n        value: []\n      },\n\n      /**\n       * @property styleRules\n       * Used internally to manage styling added to the component's internal stylesheet.\n       * @private\n       */\n      styleRules: {\n        value: {}\n      },\n\n      /**\n       * @property initialize\n       * Used internally to set up the element's Shadow Root and inject its template.\n       * @private\n       */\n      initialize: {\n        value: templateString => {\n          this.keySource = 'key' in KeyboardEvent.prototype ? 'key' : ('keyIdentifier' in KeyboardEvent.prototype ? 'keyIdentifier' : 'keyCode')\n\n          this.attachShadow({ mode: 'open' })\n\n          let container = document.createElement('div')\n          container.insertAdjacentHTML('afterbegin', templateString)\n\n          let template = container.querySelector('template')\n\n          if ('content' in template) {\n            this.shadowRoot.appendChild(template.content.cloneNode(true))\n          } else {\n            template.childNodes.forEach((child) => {\n              this.shadowRoot.appendChild(child.cloneNode(true))\n            })\n          }\n\n          template = null\n          this.crypto = null\n\n          try {\n            this.crypto = crypto\n          } catch (e) {\n            this.crypto = msCrypto\n          }\n        }\n      },\n\n      /**\n       * @method definePrivateProperty\n       * Used internally to register new private properties on the element\n       * @param  {string} name\n       * @param  {CustomPropertyObject} data\n       * @private\n       */\n      definePrivateProperty: {\n        value: (name, data) => {\n          this.PRIVATE.privateProperties[name] = null\n\n          Object.defineProperty(this.PRIVATE, name, {\n            get: () => {\n              if (data.hasOwnProperty('get')) {\n                if (typeof data.get !== 'function') {\n                  return this.UTIL.throwError({\n                    type: 'type',\n                    message: 'Property getter must be a function'\n                  })\n                }\n\n                return data.get()\n              }\n\n              return this.PRIVATE.privateProperties[name] === null ? data.default : this.PRIVATE.privateProperties[name]\n            },\n\n            set: value => {\n              if (data.readonly) {\n                return this.UTIL.throwError({\n                  type: 'readonly',\n                  vars: { prop: name }\n                })\n              }\n\n              this.PRIVATE.privateProperties[name] = value\n            }\n          })\n        }\n      },\n\n      /**\n       * @method defineReadOnlyProperty\n       * Used internally to register new readonly properties on the element.\n       * @param  {string} name\n       * @param  {CustomPropertyObject} data\n       * @private\n       */\n      defineReadOnlyProperty: {\n        value: (name, data) => {\n          let cfg = {\n            set: value => {\n              this.UTIL.throwError({\n                type: 'readonly',\n                vars: { prop: name }\n              })\n            },\n\n            get: () => {\n              if (data.hasOwnProperty('get')) {\n                if (typeof data.get !== 'function') {\n                  return this.UTIL.throwError({\n                    type: 'type',\n                    message: 'Property getter must be a function'\n                  })\n                }\n\n                return data.get()\n              }\n\n              return data.hasOwnProperty('default') ? data.default : null\n            }\n          }\n\n          Object.defineProperty(this, name, cfg)\n        }\n      },\n\n      /**\n       * @method generateAuthorHTMLCollectionConstructor\n       * Generates a class constructor for an AuthorHTMLCollection\n       * @returns {AuthorHTMLCollection}\n       * @private\n       */\n      generateAuthorHTMLCollectionConstructor: {\n        value: function () {\n          let _p = new WeakMap()\n\n          let AuthorHTMLCollection = class AuthorHTMLCollection {\n            constructor (arr) {\n              _p.set(this, { arr })\n              arr.forEach((node, index) => {\n                this[index] = node\n\n                if (node.id) {\n                  this[node.id] = node\n                }\n              })\n            }\n\n            get length () {\n              return _p.get(this).arr.length\n            }\n\n            item (index) {\n              return _p.get(this).arr[index]\n            }\n\n            namedItem (name) {\n              let matches = _p.get(this).arr.filter(item => item.id === name || item.name === name)\n              return matches.length > 0 ? matches[0] : null\n            }\n\n            [Symbol.iterator] () {\n              let index = 0\n\n              return {\n                next: () => {\n                  let result = {\n                    value: _p.get(this).arr[index],\n                    done: !(index in _p.get(this).arr)\n                  }\n\n                  index++\n\n                  return result\n                }\n              }\n            }\n\n            [Symbol.toStringTag] () {\n              return 'AuthorHTMLCollection'\n            }\n          }\n\n          return AuthorHTMLCollection\n        }\n      },\n\n      getStyleRule: {\n        value: name => {\n          let rule = this.PRIVATE.styleRules[name]\n\n          if (!rule) {\n            return this.UTIL.throwError({\n              message: `Style Rule \"${name}\" not found`\n            })\n          }\n\n          return rule\n        }\n      },\n\n      /**\n       * @method getBooleanAttributeValue\n       * Used internally. Returns a validated boolean attribute value.\n       * @param  {string} name\n       * @return {boolean}\n       * @private\n       */\n      getBooleanAttributeValue: {\n        value: name => this.hasAttribute(name) && this.getAttribute(name) !== 'false'\n      },\n\n      /**\n       * @method setBooleanAttributeValue\n       * Used internally. Ensures that a boolean attribute recieves a valid\n       * boolean as a value.\n       * @param  {string} name\n       * @param  {any} value\n       * @private\n       */\n      setBooleanAttributeValue: {\n        value: (name, value) => {\n          if (typeof value === 'boolean') {\n            value = value.toString()\n          }\n\n          let acceptableValues = ['true', 'false', '', null]\n\n          if (!acceptableValues.includes(value)) {\n            this.UTIL.printToConsole(`\"${name}\" attribute expected boolean but received \"${value}\"`, 'error')\n            return this.removeAttribute(name)\n          }\n\n          switch (value) {\n            case 'false':\n            case null:\n              return this.removeAttribute(name)\n\n            case 'true':\n            case '':\n              return this.setAttribute(name, '')\n          }\n        }\n      },\n    })\n\n    Object.defineProperties(this.UTIL, {\n      /**\n       * @property childMonitor\n       * The MutationObserver instance created upon calling this.UTIL.monitorChildren.\n       * @type {MutationObserver}\n       */\n      childMonitor: {\n        value: null\n      },\n\n      /**\n       * @typedef {object} CustomAttributeObject shape: {\n       *   get: {function} Custom getter\n       *   set: {function} Custom setter\n       *   default: {any} Default value\n       * }\n       */\n\n      /**\n       * @method defineAttribute\n       * Registers a new attribute on the element and connects it to a new\n       * property of the same name.\n       * @param  {string} name\n       * @param  {string|number|boolean|CustomAttributeObject} defaultValue\n       * If a default value is passed, or if a CustomAttributeObject is passed\n       * which includes a \"default\" property, getters will be applied that\n       * return the default value if the actual value is null or undefined.\n       */\n      defineAttribute: {\n        value: (name, defaultValue) => {\n          let customGetter = null\n          let customSetter = null\n\n          if (typeof defaultValue === 'object') {\n            let cfg = defaultValue\n\n            if (cfg.hasOwnProperty('get')) {\n              customGetter = cfg.get\n            }\n\n            if (cfg.hasOwnProperty('set')) {\n              customSetter = cfg.set\n            }\n\n            defaultValue = cfg.hasOwnProperty('default') ? cfg.default : null\n          }\n\n          let isBool = typeof defaultValue === 'boolean'\n          let privateKey = isBool ? 'booleanAttributes' : 'attributes'\n\n          Object.defineProperty(this.PRIVATE[privateKey], name, {\n            get: () => {\n              if (customGetter) {\n                let result = customGetter()\n                return result === null ? defaultValue : result\n              }\n\n              return defaultValue\n            },\n\n            set: value => customSetter && customSetter(value)\n          })\n\n          Object.defineProperty(this, name, {\n            get: () => {\n              if (customGetter) {\n                let result = customGetter()\n                return result === null ? defaultValue : result\n              }\n\n              if (isBool) {\n                return this.PRIVATE.getBooleanAttributeValue(name)\n              }\n\n              return this.hasAttribute(name) ? this.getAttribute(name) : defaultValue\n            },\n\n            set: value => {\n              customSetter && customSetter(value)\n\n              if (customGetter) {\n                value = this.PRIVATE[privateKey][name]\n              }\n\n              if (isBool) {\n                return this.PRIVATE.setBooleanAttributeValue(name, value)\n              }\n\n              this.setAttribute(name, value)\n            }\n          })\n        }\n      },\n\n      /**\n       * @method defineAttributes\n       * Define multiple attributes at once.\n       * @param  {object} attrs\n       * Example:\n       * {\n       *   booleanAttr: false,\n       *   stringAttr: 'string',\n       *   customAttr: {\n       *     get: () => this.customAttribute,\n       *     default: 'defaultValue'\n       *   }\n       * }\n       *\n       * Custom attributes are configured as CustomAttributeObject\n       */\n      defineAttributes: {\n        value: attrs => {\n          for (let attr in attrs) {\n            this.UTIL.defineAttribute(attr, attrs[attr])\n          }\n        }\n      },\n\n      /**\n       * @typedef {object} CustomPropertyObject shape: {\n       *   readonly: {boolean} optional\n       *   private: {boolean} optional,\n       *   default: {any} Default property value,\n       *   get: {function} Custom Getter,\n       *   set: {function} Custom setter\n       * }\n       */\n\n      /**\n       * @method defineProperty\n       * Registers a custom property on the element. If an attribute of the same\n       * name already exists, its paired property will be overwritten.\n       * @param  {string} name\n       * @param  {string|boolean|number|CustomPropertyObject} value\n       */\n      defineProperty: {\n        value: (name, value) => {\n          if (typeof value !== 'object' || value === null) {\n            this.PRIVATE.properties[name] = value\n            this[name] = value\n            return\n          }\n\n          let data = {\n            readonly: value.hasOwnProperty('readonly') && value.readonly === true,\n            private: value.hasOwnProperty('private') && value.private === true,\n            default: value.hasOwnProperty('default') ? value.default : null\n          }\n\n          if (value.hasOwnProperty('get')) {\n            if (typeof value.get !== 'function') {\n              return this.UTIL.throwError({\n                type: 'type',\n                message: 'Property getter must be a function'\n              })\n            }\n\n            data.get = value.get\n          }\n\n          if (value.hasOwnProperty('set')) {\n            if (typeof value.set !== 'function') {\n              return this.UTIL.throwError({\n                type: 'type',\n                message: 'Property setter must be a function'\n              })\n            }\n\n            data.set = value.set\n          }\n\n          if (value.private) {\n            return this.PRIVATE.definePrivateProperty(name, data)\n          }\n\n          if (value.readonly) {\n            return this.PRIVATE.defineReadOnlyProperty(name, data)\n          }\n\n          this.PRIVATE.properties[name] = data.default\n\n          Object.defineProperty(this, name, {\n            get: () => {\n              if (data.hasOwnProperty('get')) {\n                return data.get()\n              }\n\n              return this.PRIVATE.properties[name] === null ? data.default : this.PRIVATE.properties[name]\n            },\n\n            set: value => {\n              if (data.hasOwnProperty('set')) {\n                return data.set(value)\n              }\n\n              this.PRIVATE.properties[name] = value\n            }\n          })\n        }\n      },\n\n      /**\n       * @method defineProperties\n       * Register multiple properties at once on the element.\n       * @param  {object} properties\n       * Example: {\n       *   booleanProperty: false,\n       *   stringProperty: 'string',\n       *   customProperty: {\n       *     readonly: true,\n       *     private: true,\n       *     get: () => {\n       *       doSomething()\n       *       return this.customProperty\n       *     },\n       *     default: 'default value'\n       *   }\n       * }\n       */\n      defineProperties: {\n        value: properties => {\n          for (let property in properties) {\n            this.UTIL.defineProperty(property, properties[property])\n          }\n        }\n      },\n\n      /**\n       * @method definePrivateMethods\n       * Register multiple private methods on the element. These will be added\n       * tp the element's \"PRIVATE\" object and can be accessed via this.PRIVATE.*\n       * @param  {object} methods\n       * Example {\n       *   myPrivateMethod: () => doSomething()\n       * }\n       */\n      definePrivateMethods: {\n        value: methods => {\n          for (let method in methods) {\n            if (this.PRIVATE.hasOwnProperty(method)) {\n              return this.UTIL.throwError({\n                message: `Cannot create private method. Property name \"${method}\" is already in use.`\n              })\n            }\n\n            this.PRIVATE[method] = methods[method]\n          }\n        }\n      },\n\n      /**\n       * @method createEvent\n       * Returns a new CustomEvent object.\n       * @param  {[type]} name\n       * Name of the event\n       * @param  {object} detail\n       * Properties to add to event.detail\n       * @return {CustomEvent}\n       */\n      createEvent: {\n        value: (name, detail) => {\n          return new CustomEvent(name, { detail })\n        }\n      },\n\n      /**\n       * @method generateGuid\n       * @param  {string} [prefix=null]\n       * String to prepend to the beginning of the id.\n       * @param  {string} [postfix=null]\n       * String to append to the end of the id.\n       * @return {string}\n       * New RFC-compliant GUID\n       */\n      generateGuid: {\n        value: (prefix = null, postfix = null) => {\n          let id = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => { // eslint-disable-line space-infix-ops\n            return (c ^ this.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n          })\n\n          if (prefix) {\n            id = `${prefix}${id}`\n          }\n\n          if (postfix) {\n            id = `${id}${postfix}`\n          }\n\n          return id\n        }\n      },\n\n      /**\n       * @method insertStyleRule\n       * Inserts a new CSS rule-set into the component's shadow root style sheet.\n       * @param {string} name\n       * Unique identifier to be used as an accessor for this rule-set\n       * @param {string} selector\n       * CSS selector string\n       * @param {number} index [optional]\n       * Index at which to add the new style rule\n       */\n      insertStyleRule: {\n        value: (name, selector, index = this.PRIVATE.styleSheet.cssRules.length) => {\n          this.PRIVATE.styleSheet.insertRule(selector, index)\n          this.PRIVATE.styleRules[name] = {\n            default: this.PRIVATE.styleSheet.cssRules[index],\n          }\n\n          if (selector.includes(':host(')) {\n            selector = `${this.localName}${/\\(([^)]+)\\)/.exec(selector)[1]} {}`\n            index += 1\n\n            if (selector) {\n              this.PRIVATE.styleSheet.insertRule(selector, index)\n              this.PRIVATE.styleRules[name].legacy = this.PRIVATE.styleSheet.cssRules[index]\n            }\n          }\n        }\n      },\n\n      /**\n       * @method insertStyleRules\n       * Inserts one or more new CSS rule-sets into the component's shadow root style sheet.\n       * @param {object} rules\n       * CSS selector string or definition object. If using a definition object, the key name\n       * will be used as an accessor for this rule.\n       * @param {string} rules.selector\n       * CSS selector string\n       * @param {string} rules.index [optional]\n       * Index at which to insert the new rule into the style sheet.\n       */\n      insertStyleRules: {\n        value: rules => {\n          for (let rule in rules) {\n            let input = rules[rule]\n\n            if (typeof input === 'string') {\n              this.UTIL.insertStyleRule(rule, input)\n              continue\n            }\n\n            if (Array.isArray(input) || typeof input !== 'object') {\n              return this.UTIL.throwError({\n                type: 'type',\n                message: `Invalid Style Rule definition \"${JSON.stringify(input)}\". Definitions must either be a valid CSS selector string or an object`\n              })\n            }\n\n            if (!input.hasOwnProperty('selector')) {\n              return this.UTIL.throwError({\n                message: 'Style Rule Definition must include a \"selector\" property'\n              })\n            }\n\n            this.insertStyleRule(rule, input.selector, input.hasOwnProperty('index') ? input.index : null)\n          }\n        }\n      },\n\n      /**\n       * @method removeStyleProperty\n       * Removes a style property declaration from the specified rule in the component's shadow root style sheet.\n       * @param {string} ruleName\n       * Name of the rule\n       * @param {string} propertyName\n       * CSS property name\n       */\n      removeStyleProperty: {\n        value: (ruleName, propertyName) => {\n          let rule = this.PRIVATE.getStyleRule(ruleName)\n\n          rule.default.style.removeProperty(propertyName)\n\n          if (rule.hasOwnProperty('legacy')) {\n            rule.legacy.style.removeProperty(propertyName)\n          }\n        }\n      },\n\n      /**\n       * @method removeStyleProperties\n       * Removes a set of style property declarations from the specified rule in the component's shadow root style sheet.\n       * @param {string} ruleName\n       * Name of the rule\n       * @param {array} propertyNames\n       * Names of the CSS properties to remove\n       */\n      removeStyleProperties: {\n        value: (ruleName, propertyNames) => {\n          if (!Array.isArray(propertyNames)) {\n            return this.UTIL.throwError({\n              type: 'type',\n              message: `Style property names must be an array of strings`\n            })\n          }\n\n          propertyNames.forEach(propertyName => this.UTIL.removeStyleProperty(ruleName, propertyName))\n        }\n      },\n\n      /**\n       * @method setStyleProperty\n       * Adds a new style declaration to the component's shadow root style sheet, or updates an existing one.\n       * @param {string} ruleName\n       * String identifier for the style rule to add the declaration to.\n       * @param {string} propertyName\n       * CSS property\n       * @param {string} propertyValue\n       * CSS property value\n       * @param {boolean} important [optional]\n       * true sets the important flag on this property declaration.\n       */\n      setStyleProperty: {\n        value: (ruleName, propertyName, propertyValue, important = false) => {\n          let rule = this.PRIVATE.getStyleRule(ruleName)\n\n          rule.default.style.setProperty(propertyName, propertyValue, important ? 'important' : undefined)\n\n          if (rule.hasOwnProperty('legacy')) {\n            rule.legacy.style.setProperty(propertyName, propertyValue, important ? 'important' : undefined)\n          }\n        }\n      },\n\n      /**\n       * @method setStyleProperties\n       * Adds a set of new style declarations to the component's shadow root style sheet, or updates existing ones.\n       * @param {string} ruleName\n       * String identifier for the style rule to add the declaration to.\n       * @param {array} properties\n       * Array of objects of shape: {\n       *   name: {string} CSS property name,\n       *   value: {string} CSS property value,\n       *   important: {boolean} Determines whether or not to set the !important flag [optional]\n       * }\n       */\n      setStyleProperties: {\n        value: (ruleName, properties) => {\n          if (!Array.isArray(properties)) {\n            return this.UTIL.throwError({\n              type: 'type',\n              message: `Style properties must be an array of objects`\n            })\n          }\n\n          properties.forEach(property => {\n            let important = property.hasOwnProperty('important') && property.important === true\n            this.UTIL.setStyleProperty(ruleName, property.name, property.value, important)\n          })\n        }\n      },\n\n      /**\n       * @typedef {string} ErrorType (custom, dependency, readonly, reference, type)\n       * Indentifier for JavaScript built-in Error types including:\n       * Error, TypeError, ReferenceError, or custom Error\n       */\n\n      /**\n       * @method throwError\n       * Throws a customizable new Error.\n       * @param {object} properties\n       * @property {ErrorType} type\n       * Type of error to throw. For example, 'reference' will throw a\n       * new ReferenceError() instance, while 'type' will throw a new TypeError()\n       * instance. Other values will throw customizable new Error() instances.\n       * @property {object} vars\n       * Some error types have default messages which accept interpolated variables.\n       * For example, 'dependency' errors accept an options 'name' variable, the\n       * value of which should be the name of the missing dependency. They also\n       * accept a 'url' variable, the value of which should be a url where the\n       * dependency can be acquired.\n       * @property {string} message\n       * A custom message to append to the default error message.\n       *\n       * Example usage:\n       * ```js\n       * this.UTIL.throwError({\n       *   type: 'dependency',\n       *   vars: {\n       *     name: 'NGN',\n       *     url: 'https://github.com/ngnjs/NGN'\n       *   },\n       *   message: 'NGN makes development a breeze!'\n       * })\n       * ```\n       */\n      throwError: {\n        value: properties => {\n          let finalMessage = `<${this.localName}> `\n\n          let type = properties.hasOwnProperty('type') ? properties.type : 'custom'\n          let error = new Error()\n          let { vars } = properties\n\n          if (type === 'dependency') {\n            finalMessage += 'Missing dependency'\n\n            if (vars) {\n              if (vars.hasOwnProperty('name')) {\n                finalMessage += `: ${vars.name}`\n              }\n\n              if (vars.hasOwnProperty('url')) {\n                finalMessage += ` ${vars.url}`\n              }\n            }\n\n          } else if (type === 'readonly') {\n            finalMessage += `Cannot set read-only property`\n\n            if (vars && vars.hasOwnProperty('prop')) {\n              finalMessage += ` \"${vars.prop}\"`\n            }\n\n          } else if (type === 'reference') {\n            error = new ReferenceError()\n\n          } else if (type === 'type') {\n            error = new TypeError()\n\n          } else {\n            return this.UTIL.throwError({\n              message: `Unrecognized error type \"${type}\". Accepted types: \"custom\", \"dependency\", \"readonly\", \"reference\", \"type\"`\n            })\n          }\n\n          if (properties.hasOwnProperty('message')) {\n            finalMessage += ` ${properties.message}`\n          }\n\n          error.message = finalMessage.trim()\n          throw error\n        }\n      },\n\n      /**\n        * @typedef {string} ConsoleLogType (warning, error, info, log)\n        * Indentifier for window.console built-in methods including:\n        * warn(), error(), info(), log()\n        */\n\n      /**\n       * @method printToConsole\n       * Prints a message to the console, along with the tag-name of the element.\n       * Can print customizable warnings, errors, info, or default logs.\n       * @param {string} message\n       * Message to print.\n       * @param {ConsoleLogType} [type = 'log']\n       * Type of message to print to the console. This will determine which\n       * method of the window.console object is used to print the message.\n       */\n      printToConsole: {\n        value: (message, type = 'log') => {\n          let finalMessage = `<${this.localName}> ${message}`\n\n          switch (type) {\n            case 'warning': return console.warn(`[WARNING] ${finalMessage}`)\n            case 'error': return console.error(`[ERROR] ${finalMessage}`)\n            case 'info': return console.info(finalMessage)\n            default: return console.log(finalMessage)\n          }\n        }\n      },\n\n      /**\n       * @method monitorChildren\n       * Applies a MutationObserver to the element.\n       * @param {function} callback\n       * Runs when a mutation occurs\n       * @param {Boolean} [subtree = false]\n       * Determines whether or not to observe changes to the descendants of the target node\n       */\n      monitorChildren: {\n        value: (callback, cfg = null) => {\n          this.childMonitor = new MutationObserver(callback)\n\n          cfg = cfg || {\n            childList: true,\n            attributes: false,\n            characterData: false,\n            subtree: false\n          }\n\n          this.childMonitor.observe(this, cfg)\n        }\n      },\n\n      /**\n       * @method registerListener\n       * Applies an event listener. This listener will be automatically cleaned up\n       * upon element disconnect.\n       * @param {DOMNode} element\n       * Element to which to apply the event listener.\n       * @param {string} evtName\n       * Name of the event to listen to.\n       * @param {function} callback\n       * Function to call upon firing of the event.\n       */\n      registerListener: {\n        value: (element, evtName, callback) => {\n          let listener = {\n            id: `listener_${this.UTIL.generateGuid()}`,\n            apply: () => element.addEventListener(evtName, callback),\n            remove: () => element.removeEventListener(evtName, callback)\n          }\n\n          this.PRIVATE.listeners.push(listener)\n          listener.apply()\n        }\n      },\n\n      /**\n       * @method registerListeners\n       * Applies multiple event listeners at once. Each listener will be automatically cleaned up\n       * upon element disconnect.\n       * @param {DOMNode} element\n       * Element to which to apply all the event listeners.\n       * @param {{name: String, callback: Function}[]} listeners\n       * Event Listeners to apply.\n       */\n      registerListeners: {\n        value: (element, listeners) => {\n          for (let listener in listeners) {\n            this.UTIL.registerListener(element, listener, listeners[listener])\n          }\n        }\n      }\n    })\n\n    this.PRIVATE.initialize(templateString)\n  }\n\n  /**\n   * @override\n   * @method attributeChangedCallback\n   * Synchronizes attribute/property updates.\n   * @param  {string} attribute\n   * @param  {string} oldValue\n   * @param  {string} newValue\n   * @fires attribute.change\n   * Fires before change is applied to matching properties.\n   * @fires attribute.changed\n   * Fires after change has been applied to matching properties.\n   */\n  attributeChangedCallback (attribute, oldValue, newValue) {\n    this.emit('attribute.change', {\n      attribute,\n      oldValue,\n      newValue\n    })\n\n    let { attributes, booleanAttributes } = this.PRIVATE\n\n    if (attributes.hasOwnProperty(attribute) && attributes[attribute] !== newValue) {\n      this.PRIVATE.attributes[attribute] = newValue\n    } else if (booleanAttributes.hasOwnProperty(attribute) && newValue !== 'true' && newValue !== '') {\n      this.PRIVATE.booleanAttributes[attribute] = newValue\n    }\n\n    this.emit('attribute.changed', {\n      attribute,\n      oldValue,\n      newValue\n    })\n  }\n\n  /**\n   * @override\n   * @method connectedCallback\n   * Fires events upon element connection.\n   * @fires 'connected'\n   * @fires 'rendered'\n   * Fires once the element's children have been rendered to the DOM.\n   */\n  connectedCallback () {\n    Object.defineProperty(this.PRIVATE, 'styleSheet', {\n      value: this.shadowRoot.querySelector('style').sheet\n    })\n\n    this.emit('connected')\n    setTimeout(() => this.emit('rendered'), 0)\n  }\n\n  /**\n   * @override\n   * @method disconnectedCallback\n   * Removes all registered event listeners upon element disconnect.\n   * @fires 'disconnected'\n   */\n  disconnectedCallback () {\n    this.PRIVATE.listeners.forEach(listener => listener.remove())\n    this.emit('disconnected')\n  }\n\n  /**\n   * @method emit\n   * Dispatches a new CustomEvent()\n   * @param  {string} name\n   * Name of event to dispatch\n   * @param  {object} detail\n   * Data object to include in the event's payload\n   * @param  {HTMLElement} [target=null]\n   * DOM node to fire the event at.\n   */\n  emit (name, detail, target = null) {\n    let event = this.UTIL.createEvent(name, detail)\n\n    if (target) {\n      return target.dispatchEvent(event)\n    }\n\n    this.dispatchEvent(event)\n  }\n\n  /**\n   * @method off\n   * Convenience method. Removes an event listener from the element.\n   * @param  {string}   evtName\n   * @param  {function} handler\n   */\n  off (evtName, handler) {\n    this.removeEventListener(evtName, handler)\n  }\n\n  /**\n   * @method on\n   * Convenience method. Attaches an event listener to the element.\n   * @param  {string}   evtName\n   * @param  {function} handler\n   * Called when the event is fired.\n   */\n  on (evtName, handler) {\n    this.addEventListener(evtName, handler)\n  }\n}\n\nexport default AuthorBaseElement\n"],"names":["superClass","[object Object]","templateString","super","Object","defineProperties","this","PRIVATE","value","UTIL","attributes","booleanAttributes","properties","privateProperties","listeners","styleRules","initialize","keySource","KeyboardEvent","prototype","attachShadow","mode","container","document","createElement","insertAdjacentHTML","template","querySelector","shadowRoot","appendChild","content","cloneNode","childNodes","forEach","child","crypto","e","msCrypto","definePrivateProperty","name","data","defineProperty","get","hasOwnProperty","throwError","type","message","default","set","readonly","vars","prop","defineReadOnlyProperty","cfg","generateAuthorHTMLCollectionConstructor","_p","WeakMap","arr","node","index","id","length","matches","filter","item","Symbol","iterator","next","result","done","toStringTag","getStyleRule","rule","getBooleanAttributeValue","hasAttribute","getAttribute","setBooleanAttributeValue","toString","includes","printToConsole","removeAttribute","setAttribute","childMonitor","defineAttribute","defaultValue","customGetter","customSetter","isBool","privateKey","defineAttributes","attrs","attr","private","property","definePrivateMethods","methods","method","createEvent","detail","CustomEvent","generateGuid","prefix","postfix","replace","c","getRandomValues","Uint8Array","insertStyleRule","selector","styleSheet","cssRules","insertRule","localName","exec","legacy","insertStyleRules","rules","input","Array","isArray","JSON","stringify","removeStyleProperty","ruleName","propertyName","style","removeProperty","removeStyleProperties","propertyNames","setStyleProperty","propertyValue","important","setProperty","undefined","setStyleProperties","finalMessage","error","Error","url","ReferenceError","TypeError","trim","console","warn","info","log","monitorChildren","callback","MutationObserver","childList","characterData","subtree","observe","registerListener","element","evtName","listener","apply","addEventListener","remove","removeEventListener","push","registerListeners","attribute","oldValue","newValue","emit","sheet","setTimeout","target","event","dispatchEvent","handler"],"mappings":"qDAA0BA,IAAc,cAAcA,EACpDC,YAAaC,GACXC,QAEAC,OAAOC,iBAAiBC,KAAM,CAM5BC,QAAS,CACPC,MAAO,IAQTC,KAAM,CACJD,MAAO,MAIXJ,OAAOC,iBAAiBC,KAAKC,QAAS,CAMpCG,WAAY,CACVF,MAAO,IAQTG,kBAAmB,CACjBH,MAAO,IAQTI,WAAY,CACVJ,MAAO,IAQTK,kBAAmB,CACjBL,MAAO,IAQTM,UAAW,CACTN,MAAO,IAQTO,WAAY,CACVP,MAAO,IAQTQ,WAAY,CACVR,MAAON,IACLI,KAAKW,UAAY,QAASC,cAAcC,UAAY,MAAS,kBAAmBD,cAAcC,UAAY,gBAAkB,UAE5Hb,KAAKc,aAAa,CAAEC,KAAM,SAE1B,IAAIC,EAAYC,SAASC,cAAc,OACvCF,EAAUG,mBAAmB,aAAcvB,GAE3C,IAAIwB,EAAWJ,EAAUK,cAAc,YAEnC,YAAaD,EACfpB,KAAKsB,WAAWC,YAAYH,EAASI,QAAQC,WAAU,IAEvDL,EAASM,WAAWC,QAASC,IAC3B5B,KAAKsB,WAAWC,YAAYK,EAAMH,WAAU,MAIhDL,EAAW,KACXpB,KAAK6B,OAAS,KAEd,IACE7B,KAAK6B,OAASA,OACd,MAAOC,GACP9B,KAAK6B,OAASE,YAYpBC,sBAAuB,CACrB9B,MAAO,CAAC+B,EAAMC,KACZlC,KAAKC,QAAQM,kBAAkB0B,GAAQ,KAEvCnC,OAAOqC,eAAenC,KAAKC,QAASgC,EAAM,CACxCG,IAAK,IACCF,EAAKG,eAAe,OACE,mBAAbH,EAAKE,IACPpC,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,OACNC,QAAS,uCAINN,EAAKE,MAGkC,OAAzCpC,KAAKC,QAAQM,kBAAkB0B,GAAiBC,EAAKO,QAAUzC,KAAKC,QAAQM,kBAAkB0B,GAGvGS,IAAKxC,IACH,GAAIgC,EAAKS,SACP,OAAO3C,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,WACNK,KAAM,CAAEC,KAAMZ,KAIlBjC,KAAKC,QAAQM,kBAAkB0B,GAAQ/B,OAa/C4C,uBAAwB,CACtB5C,MAAO,CAAC+B,EAAMC,KACZ,IAAIa,EAAM,CACRL,IAAKxC,IACHF,KAAKG,KAAKmC,WAAW,CACnBC,KAAM,WACNK,KAAM,CAAEC,KAAMZ,MAIlBG,IAAK,IACCF,EAAKG,eAAe,OACE,mBAAbH,EAAKE,IACPpC,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,OACNC,QAAS,uCAINN,EAAKE,MAGPF,EAAKG,eAAe,WAAaH,EAAKO,QAAU,MAI3D3C,OAAOqC,eAAenC,KAAMiC,EAAMc,KAUtCC,wCAAyC,CACvC9C,MAAO,WACL,IAAI+C,EAAK,IAAIC,QAiDb,OA/C2B,MACzBvD,YAAawD,GACXF,EAAGP,IAAI1C,KAAM,CAAEmD,IAAAA,IACfA,EAAIxB,QAAQ,CAACyB,EAAMC,KACjBrD,KAAKqD,GAASD,EAEVA,EAAKE,KACPtD,KAAKoD,EAAKE,IAAMF,KAKtBG,aACE,OAAON,EAAGb,IAAIpC,MAAMmD,IAAII,OAG1B5D,KAAM0D,GACJ,OAAOJ,EAAGb,IAAIpC,MAAMmD,IAAIE,GAG1B1D,UAAWsC,GACT,IAAIuB,EAAUP,EAAGb,IAAIpC,MAAMmD,IAAIM,OAAOC,GAAQA,EAAKJ,KAAOrB,GAAQyB,EAAKzB,OAASA,GAChF,OAAOuB,EAAQD,OAAS,EAAIC,EAAQ,GAAK,KAG3C7D,CAACgE,OAAOC,YACN,IAAIP,EAAQ,EAEZ,MAAO,CACLQ,KAAM,KACJ,IAAIC,EAAS,CACX5D,MAAO+C,EAAGb,IAAIpC,MAAMmD,IAAIE,GACxBU,OAAQV,KAASJ,EAAGb,IAAIpC,MAAMmD,MAKhC,OAFAE,IAEOS,IAKbnE,CAACgE,OAAOK,eACN,MAAO,2BAQfC,aAAc,CACZ/D,MAAO+B,IACL,IAAIiC,EAAOlE,KAAKC,QAAQQ,WAAWwB,GAEnC,OAAKiC,GACIlE,KAAKG,KAAKmC,WAAW,CAC1BE,uBAAwBP,mBAehCkC,yBAA0B,CACxBjE,MAAO+B,GAAQjC,KAAKoE,aAAanC,IAAqC,UAA5BjC,KAAKqE,aAAapC,IAW9DqC,yBAA0B,CACxBpE,MAAO,CAAC+B,EAAM/B,KAOZ,GANqB,kBAAVA,IACTA,EAAQA,EAAMqE,aAGO,CAAC,OAAQ,QAAS,GAAI,MAEvBC,SAAStE,GAE7B,OADAF,KAAKG,KAAKsE,mBAAmBxC,+CAAkD/B,KAAU,SAClFF,KAAK0E,gBAAgBzC,GAG9B,OAAQ/B,GACN,IAAK,QACL,KAAK,KACH,OAAOF,KAAK0E,gBAAgBzC,GAE9B,IAAK,OACL,IAAK,GACH,OAAOjC,KAAK2E,aAAa1C,EAAM,SAMzCnC,OAAOC,iBAAiBC,KAAKG,KAAM,CAMjCyE,aAAc,CACZ1E,MAAO,MAqBT2E,gBAAiB,CACf3E,MAAO,CAAC+B,EAAM6C,KACZ,IAAIC,EAAe,KACfC,EAAe,KAEnB,GAA4B,iBAAjBF,EAA2B,CACpC,IAAI/B,EAAM+B,EAEN/B,EAAIV,eAAe,SACrB0C,EAAehC,EAAIX,KAGjBW,EAAIV,eAAe,SACrB2C,EAAejC,EAAIL,KAGrBoC,EAAe/B,EAAIV,eAAe,WAAaU,EAAIN,QAAU,KAG/D,IAAIwC,EAAiC,kBAAjBH,EAChBI,EAAaD,EAAS,oBAAsB,aAEhDnF,OAAOqC,eAAenC,KAAKC,QAAQiF,GAAajD,EAAM,CACpDG,IAAK,KACH,GAAI2C,EAAc,CAChB,IAAIjB,EAASiB,IACb,OAAkB,OAAXjB,EAAkBgB,EAAehB,EAG1C,OAAOgB,GAGTpC,IAAKxC,GAAS8E,GAAgBA,EAAa9E,KAG7CJ,OAAOqC,eAAenC,KAAMiC,EAAM,CAChCG,IAAK,KACH,GAAI2C,EAAc,CAChB,IAAIjB,EAASiB,IACb,OAAkB,OAAXjB,EAAkBgB,EAAehB,EAG1C,OAAImB,EACKjF,KAAKC,QAAQkE,yBAAyBlC,GAGxCjC,KAAKoE,aAAanC,GAAQjC,KAAKqE,aAAapC,GAAQ6C,GAG7DpC,IAAKxC,IAOH,GANA8E,GAAgBA,EAAa9E,GAEzB6E,IACF7E,EAAQF,KAAKC,QAAQiF,GAAYjD,IAG/BgD,EACF,OAAOjF,KAAKC,QAAQqE,yBAAyBrC,EAAM/B,GAGrDF,KAAK2E,aAAa1C,EAAM/B,QAsBhCiF,iBAAkB,CAChBjF,MAAOkF,IACL,IAAK,IAAIC,KAAQD,EACfpF,KAAKG,KAAK0E,gBAAgBQ,EAAMD,EAAMC,MAsB5ClD,eAAgB,CACdjC,MAAO,CAAC+B,EAAM/B,KACZ,GAAqB,iBAAVA,GAAgC,OAAVA,EAG/B,OAFAF,KAAKC,QAAQK,WAAW2B,GAAQ/B,OAChCF,KAAKiC,GAAQ/B,GAIf,IAAIgC,EAAO,CACTS,SAAUzC,EAAMmC,eAAe,cAAkC,IAAnBnC,EAAMyC,SACpD2C,QAASpF,EAAMmC,eAAe,aAAgC,IAAlBnC,EAAMoF,QAClD7C,QAASvC,EAAMmC,eAAe,WAAanC,EAAMuC,QAAU,MAG7D,GAAIvC,EAAMmC,eAAe,OAAQ,CAC/B,GAAyB,mBAAdnC,EAAMkC,IACf,OAAOpC,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,OACNC,QAAS,uCAIbN,EAAKE,IAAMlC,EAAMkC,IAGnB,GAAIlC,EAAMmC,eAAe,OAAQ,CAC/B,GAAyB,mBAAdnC,EAAMwC,IACf,OAAO1C,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,OACNC,QAAS,uCAIbN,EAAKQ,IAAMxC,EAAMwC,IAGnB,OAAIxC,EAAMoF,QACDtF,KAAKC,QAAQ+B,sBAAsBC,EAAMC,GAG9ChC,EAAMyC,SACD3C,KAAKC,QAAQ6C,uBAAuBb,EAAMC,IAGnDlC,KAAKC,QAAQK,WAAW2B,GAAQC,EAAKO,aAErC3C,OAAOqC,eAAenC,KAAMiC,EAAM,CAChCG,IAAK,IACCF,EAAKG,eAAe,OACfH,EAAKE,MAG2B,OAAlCpC,KAAKC,QAAQK,WAAW2B,GAAiBC,EAAKO,QAAUzC,KAAKC,QAAQK,WAAW2B,GAGzFS,IAAKxC,IACH,GAAIgC,EAAKG,eAAe,OACtB,OAAOH,EAAKQ,IAAIxC,GAGlBF,KAAKC,QAAQK,WAAW2B,GAAQ/B,QAwBxCH,iBAAkB,CAChBG,MAAOI,IACL,IAAK,IAAIiF,KAAYjF,EACnBN,KAAKG,KAAKgC,eAAeoD,EAAUjF,EAAWiF,MAcpDC,qBAAsB,CACpBtF,MAAOuF,IACL,IAAK,IAAIC,KAAUD,EAAS,CAC1B,GAAIzF,KAAKC,QAAQoC,eAAeqD,GAC9B,OAAO1F,KAAKG,KAAKmC,WAAW,CAC1BE,wDAAyDkD,0BAI7D1F,KAAKC,QAAQyF,GAAUD,EAAQC,MAcrCC,YAAa,CACXzF,MAAO,CAAC+B,EAAM2D,IACL,IAAIC,YAAY5D,EAAM,CAAE2D,OAAAA,KAanCE,aAAc,CACZ5F,MAAO,CAAC6F,EAAS,KAAMC,EAAU,QAC/B,IAAI1C,GAAM,CAAC,MAAM,KAAK,KAAK,KAAK,MAAM2C,QAAQ,SAAUC,IAC9CA,EAAIlG,KAAK6B,OAAOsE,gBAAgB,IAAIC,WAAW,IAAI,GAAK,IAAMF,EAAI,GAAG3B,SAAS,KAWxF,OARIwB,IACFzC,KAAQyC,IAASzC,KAGf0C,IACF1C,KAAQA,IAAK0C,KAGR1C,IAcX+C,gBAAiB,CACfnG,MAAO,CAAC+B,EAAMqE,EAAUjD,EAAQrD,KAAKC,QAAQsG,WAAWC,SAASjD,UAC/DvD,KAAKC,QAAQsG,WAAWE,WAAWH,EAAUjD,GAC7CrD,KAAKC,QAAQQ,WAAWwB,GAAQ,CAC9BQ,QAASzC,KAAKC,QAAQsG,WAAWC,SAASnD,IAGxCiD,EAAS9B,SAAS,YAEpBnB,GAAS,GADTiD,KAActG,KAAK0G,YAAY,cAAcC,KAAKL,GAAU,WAI1DtG,KAAKC,QAAQsG,WAAWE,WAAWH,EAAUjD,GAC7CrD,KAAKC,QAAQQ,WAAWwB,GAAM2E,OAAS5G,KAAKC,QAAQsG,WAAWC,SAASnD,OAiBhFwD,iBAAkB,CAChB3G,MAAO4G,IACL,IAAK,IAAI5C,KAAQ4C,EAAO,CACtB,IAAIC,EAAQD,EAAM5C,GAElB,GAAqB,iBAAV6C,EAAX,CAKA,GAAIC,MAAMC,QAAQF,IAA2B,iBAAVA,EACjC,OAAO/G,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,OACNC,0CAA2C0E,KAAKC,UAAUJ,6EAI9D,IAAKA,EAAM1E,eAAe,YACxB,OAAOrC,KAAKG,KAAKmC,WAAW,CAC1BE,QAAS,6DAIbxC,KAAKqG,gBAAgBnC,EAAM6C,EAAMT,SAAUS,EAAM1E,eAAe,SAAW0E,EAAM1D,MAAQ,WAjBvFrD,KAAKG,KAAKkG,gBAAgBnC,EAAM6C,MA8BxCK,oBAAqB,CACnBlH,MAAO,CAACmH,EAAUC,KAChB,IAAIpD,EAAOlE,KAAKC,QAAQgE,aAAaoD,GAErCnD,EAAKzB,QAAQ8E,MAAMC,eAAeF,GAE9BpD,EAAK7B,eAAe,WACtB6B,EAAK0C,OAAOW,MAAMC,eAAeF,KAavCG,sBAAuB,CACrBvH,MAAO,CAACmH,EAAUK,KAChB,IAAKV,MAAMC,QAAQS,GACjB,OAAO1H,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,OACNC,QAAS,qDAIbkF,EAAc/F,QAAQ2F,GAAgBtH,KAAKG,KAAKiH,oBAAoBC,EAAUC,MAgBlFK,iBAAkB,CAChBzH,MAAO,CAACmH,EAAUC,EAAcM,EAAeC,GAAY,KACzD,IAAI3D,EAAOlE,KAAKC,QAAQgE,aAAaoD,GAErCnD,EAAKzB,QAAQ8E,MAAMO,YAAYR,EAAcM,EAAeC,EAAY,iBAAcE,GAElF7D,EAAK7B,eAAe,WACtB6B,EAAK0C,OAAOW,MAAMO,YAAYR,EAAcM,EAAeC,EAAY,iBAAcE,KAiB3FC,mBAAoB,CAClB9H,MAAO,CAACmH,EAAU/G,KAChB,IAAK0G,MAAMC,QAAQ3G,GACjB,OAAON,KAAKG,KAAKmC,WAAW,CAC1BC,KAAM,OACNC,QAAS,iDAIblC,EAAWqB,QAAQ4D,IACjB,IAAIsC,EAAYtC,EAASlD,eAAe,eAAuC,IAAvBkD,EAASsC,UACjE7H,KAAKG,KAAKwH,iBAAiBN,EAAU9B,EAAStD,KAAMsD,EAASrF,MAAO2H,OAwC1EvF,WAAY,CACVpC,MAAOI,IACL,IAAI2H,MAAmBjI,KAAK0G,cAExBnE,EAAOjC,EAAW+B,eAAe,QAAU/B,EAAWiC,KAAO,SAC7D2F,EAAQ,IAAIC,OACZvF,KAAEA,GAAStC,EAEf,GAAa,eAATiC,EACF0F,GAAgB,qBAEZrF,IACEA,EAAKP,eAAe,UACtB4F,QAAqBrF,EAAKX,QAGxBW,EAAKP,eAAe,SACtB4F,OAAoBrF,EAAKwF,aAIxB,GAAa,aAAT7F,EACT0F,GAAgB,gCAEZrF,GAAQA,EAAKP,eAAe,UAC9B4F,QAAqBrF,EAAKC,cAGvB,GAAa,cAATN,EACT2F,EAAQ,IAAIG,mBAEP,CAAA,GAAa,SAAT9F,EAIT,OAAOvC,KAAKG,KAAKmC,WAAW,CAC1BE,oCAAqCD,gFAJvC2F,EAAQ,IAAII,UAad,MALIhI,EAAW+B,eAAe,aAC5B4F,OAAoB3H,EAAWkC,WAGjC0F,EAAM1F,QAAUyF,EAAaM,OACvBL,IAoBVzD,eAAgB,CACdvE,MAAO,CAACsC,EAASD,EAAO,SACtB,IAAI0F,MAAmBjI,KAAK0G,cAAclE,IAE1C,OAAQD,GACN,IAAK,UAAW,OAAOiG,QAAQC,kBAAkBR,KACjD,IAAK,QAAS,OAAOO,QAAQN,iBAAiBD,KAC9C,IAAK,OAAQ,OAAOO,QAAQE,KAAKT,GACjC,QAAS,OAAOO,QAAQG,IAAIV,MAalCW,gBAAiB,CACf1I,MAAO,CAAC2I,EAAU9F,EAAM,QACtB/C,KAAK4E,aAAe,IAAIkE,iBAAiBD,GAEzC9F,EAAMA,GAAO,CACXgG,WAAW,EACX3I,YAAY,EACZ4I,eAAe,EACfC,SAAS,GAGXjJ,KAAK4E,aAAasE,QAAQlJ,KAAM+C,KAepCoG,iBAAkB,CAChBjJ,MAAO,CAACkJ,EAASC,EAASR,KACxB,IAAIS,EAAW,CACbhG,eAAgBtD,KAAKG,KAAK2F,iBAC1ByD,MAAO,IAAMH,EAAQI,iBAAiBH,EAASR,GAC/CY,OAAQ,IAAML,EAAQM,oBAAoBL,EAASR,IAGrD7I,KAAKC,QAAQO,UAAUmJ,KAAKL,GAC5BA,EAASC,UAabK,kBAAmB,CACjB1J,MAAO,CAACkJ,EAAS5I,KACf,IAAK,IAAI8I,KAAY9I,EACnBR,KAAKG,KAAKgJ,iBAAiBC,EAASE,EAAU9I,EAAU8I,QAMhEtJ,KAAKC,QAAQS,WAAWd,GAe1BD,yBAA0BkK,EAAWC,EAAUC,GAC7C/J,KAAKgK,KAAK,mBAAoB,CAC5BH,UAAAA,EACAC,SAAAA,EACAC,SAAAA,IAGF,IAAI3J,WAAEA,EAAUC,kBAAEA,GAAsBL,KAAKC,QAEzCG,EAAWiC,eAAewH,IAAczJ,EAAWyJ,KAAeE,EACpE/J,KAAKC,QAAQG,WAAWyJ,GAAaE,EAC5B1J,EAAkBgC,eAAewH,IAA2B,SAAbE,GAAoC,KAAbA,IAC/E/J,KAAKC,QAAQI,kBAAkBwJ,GAAaE,GAG9C/J,KAAKgK,KAAK,oBAAqB,CAC7BH,UAAAA,EACAC,SAAAA,EACAC,SAAAA,IAYJpK,oBACEG,OAAOqC,eAAenC,KAAKC,QAAS,aAAc,CAChDC,MAAOF,KAAKsB,WAAWD,cAAc,SAAS4I,QAGhDjK,KAAKgK,KAAK,aACVE,WAAW,IAAMlK,KAAKgK,KAAK,YAAa,GAS1CrK,uBACEK,KAAKC,QAAQO,UAAUmB,QAAQ2H,GAAYA,EAASG,UACpDzJ,KAAKgK,KAAK,gBAaZrK,KAAMsC,EAAM2D,EAAQuE,EAAS,MAC3B,IAAIC,EAAQpK,KAAKG,KAAKwF,YAAY1D,EAAM2D,GAExC,GAAIuE,EACF,OAAOA,EAAOE,cAAcD,GAG9BpK,KAAKqK,cAAcD,GASrBzK,IAAK0J,EAASiB,GACZtK,KAAK0J,oBAAoBL,EAASiB,GAUpC3K,GAAI0J,EAASiB,GACXtK,KAAKwJ,iBAAiBH,EAASiB"}